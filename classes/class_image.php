<?
// Random image code
function randFN($Length=6) {
	$o='';
	for ($i=0; $i<$Length; $i++) {
		$d=rand(1,30)%2;
		$o.=$d ? chr(rand(97,122)) : chr(rand(48,57));
	}
	return $o;
}

// Upload types
// (POST) uploadv3 - file upload (web)
// (POST) uploadv7 - ptpimg.jar (java)
// (POST) uploadv2 - url rehost (web)

// Validation

/* In the past, we simply decided to check to see if it was a URL suffixed with (png|jpg|jpeg|gif). The problem
	with this method of validation is that a lot of non-static content (images generated by PHP, protected images) would not validate.
	Despite returning the proper headers and content, we would toss them out. No more of that nonsense. */

/* Return codes
	1 - valid url
	2 - invalud url, needs content check (writes data to TMP_PREFIX)
*/
function checkUrl($URL,$Unique='') {
	// Is this a valid image?
	if(preg_match("/^".IMAGE_REGEX."$/i", $URL)) {
		// This is a valid image, according to the URL
		return 1;
	} else {
		// Not so valid
		return 2;
	}
}
// Generate temporary file name
// return('/tmp/4fc67f66cb923');
// return('/tmp/4fc67f79054ab5.12316813');
function tmpName() {
	// Need more entropy? Use this, instead:
	//return TMP_PREFIX.uniqid('', true);
	return TMP_PREFIX.uniqid();
}


// getData (fileName, gen md5 hash)
// return(ext, res, type, md5, size);
function getData($f,$nomd5=false) {
	$ext=''; $res=''; $Type=0; $Md5=''; $size=0;
	if(!$nomd5) 
		$Md5=md5_file($f);
	else
		$Md5="";
	$Type = @exif_imagetype($f);
	switch ($Type) {
		case 1:
		$ext="gif";
		break;
	case 2:
		$ext="jpg";
		break;
	case 3:
		$ext="png";
		break;
	}
		
	$size=filesize($f);

	list($w,$h,$t,$a)=getimagesize($f);
	$res=$w.'x'.$h;
	return array("ext"=>$ext,"res"=>$res,"type"=>$Type,"md5"=>$Md5,"size"=>$size);
}

// Image verification class. This runs a series of tests on the image to see if it holds up
class ImageVerification {
	private $TmpName = '';
	public $EphemeralData = '';
	// Accepts a filename (absolute)
	function ImageVerification($Name) {
		$this->TmpName=&$Name;
	}
	function destroy() {
		echo "destroy!";
		settype($this, 'null');
	}
	// What does this do? It calls our getData method, grabs all that information and throws it into EphemeralData.
	// Why? If we are rehosting this image this will let us 
	function verify() {
		if(!file_exists($this->TmpName)) return false;
		$Data=getData($this->TmpName);
		// Few checks on the actual data.
		// Checking ext rather than type ensures we're dealing with a supported filetype (png/gif/jpeg)
		if($Data['ext'] && $Data['size']>0 && $Data['res']) {
			$this->EphemeralData=&$Data;
			return true;
		}
		// Obviously this isn't a valid image and needs to go away.
		return false;
	}
}

class ImageUpload {
	private $Auth=false; // Set this to false.
	// In order to complete an image upload, they must have some sort of authentication
	// Call the auth() method, verify the upload key
	private $Type=-1; // -1 = unset, 1 = php://input, 2 = file array, 3 = rehost via url
	private $Contents=""; // Data contents
	private $Verified=false;
	private $Special=array(); // "Special" field, basically for the URL/file array
	public $Results=array();
	function ImageUpload($T) {
		$this->Type=&$T;
	}

	function setSpecial($S) {
		// init
		switch($this->Type) {
			case -1:
			case 0:
				return false;
			break;
			
			case 1:
				// good to go
			break;
			
			case 2:
				$this->Special=&$S;
			break;
			
			case 3:
				$this->Special=&$S;
			break;
		}
	}
	
	function auth($Key) {
		global $ApiKeys;
		if(in_array($Key,$ApiKeys))
			$this->Auth=true;
		else
			return false;
	}
		
	// Load the data (depending on the Type) into our Contents
	function populate() {
		global $DB, $Cache;
		if(!empty($this->Contents) || !$this->Auth || $this->Type<0) return false;
		$this->Verified=false;
		$Results=array();
		switch($this->Type) {
			case -1:
			case 0:
				return false;
			break;
			
			// ajax upload
			case 1:
				// Load the image into RAM
				$this->Contents=file_get_contents("php://input");
				if(empty($this->Contents)) return false;
		
				// Generate a unique ID and move it to the ramdisk
				$Unique = uniqid();
				$TmpFile = fopen(TMP_PREFIX.$Unique, 'w+');
				fwrite($TmpFile, $this->Contents);
				
				$this->Contents=''; // Free some memory
				
				// Fetch the properties of the image
				$Verify = new ImageVerification(TMP_PREFIX.$Unique);
				if(!$Verify->verify()) continue;
				$Data = $Verify->EphemeralData;
				$DB->query("SELECT Code, Extension FROM uploads WHERE NewHash='".db_string($Data['md5'])."'");
				
				if($DB->record_count()>0) {
					unlink(TMP_PREFIX.$Unique);
					list($Code, $Extension) = $DB->next_record();
					$Results[]=array("status"=>13, "code"=>$Code, "ext"=>$Extension);
					continue;
				}
				
				$Code='';
				while($Code=randFN()) {
					if(!file_exists(IMG_DIR.'/'.$Code)) break;
				}
				rename(TMP_PREFIX.$Unique, IMG_DIR.'/'.$Code);
				
				switch($Data['type']) {
					case 1:
					case 2:
					case 3:
						$DB->query("INSERT INTO uploads
									(NewHash, Extension, Code, Resolution, Size, Type)
									VALUES(
									'".db_string($Data['md5'])."',
									'".db_string($Data['ext'])."',
									'".db_string($Code)."',
									'".db_string($Data['res'])."',
									'".db_string($Data['size'])."',
									'".db_string($Data['type'])."')");
						if($DB->affected_rows()>0) {
							$Results[]=array("status"=>1, "code"=>$Code, "ext"=>$Data['ext']);
						}
					break;
				}
			break;
			
			// file
			case 2:
				for($i=0;$i<count($this->Special['name']);$i++) {
					if(!is_uploaded_file($this->Special['tmp_name'][$i])) return false;
						
					// Load the image into RAM
					$this->Contents[$i]=file_get_contents($this->Special['tmp_name'][$i]);
					if(empty($this->Contents[$i])) return false;
			
					// Generate a unique ID and move it to the ramdisk
					$Unique = uniqid();
					$TmpFile = fopen(TMP_PREFIX.$Unique, 'w+');
					fwrite($TmpFile, $this->Contents[$i]);
					
					$this->Contents=''; // Free some memory
					
					// Fetch the properties of the image
					$Verify = new ImageVerification(TMP_PREFIX.$Unique);
					if(!$Verify->verify()) continue;
					$Data = $Verify->EphemeralData;
					$DB->query("SELECT Code, Extension FROM uploads WHERE NewHash='".db_string($Data['md5'])."'");
					
					if($DB->record_count()>0) {
						unlink(TMP_PREFIX.$Unique);
						list($Code, $Extension) = $DB->next_record();
						$Results[]=array("status"=>13, "code"=>$Code, "ext"=>$Extension);
						continue;
					}
					
					$Code='';
					while($Code=randFN()) {
						if(!file_exists(IMG_DIR.'/'.$Code)) break;
					}
					rename(TMP_PREFIX.$Unique, IMG_DIR.'/'.$Code);
					
					switch($Data['type']) {
						case 1:
						case 2:
						case 3:
							$DB->query("INSERT INTO uploads
										(NewHash, Extension, Code, Resolution, Size, Type)
										VALUES(
										'".db_string($Data['md5'])."',
										'".db_string($Data['ext'])."',
										'".db_string($Code)."',
										'".db_string($Data['res'])."',
										'".db_string($Data['size'])."',
										'".db_string($Data['type'])."')");
							if($DB->affected_rows()>0) {
								$Results[]=array("status"=>1, "code"=>$Code, "ext"=>$Data['ext']);
							}
						break;
					}

				}
			break;
			
			case 3:
				if(empty($this->Special)) return false;
				
				if(!is_array($this->Special)) {
					// Convert to an array
					$Urls=array();
					if(strpos($this->Special, "\n")) {
						$Urls=explode("\n",$this->Special);
					} else {
						$Urls[]=$this->Special;
					}
					$this->Special=&$Urls;
				}
				
				foreach($this->Special as $URL) {
					// Load the image into RAM
					$Image=file_get_contents($URL);
					
					// Generate a unique ID and move it to the ramdisk
					$Unique = uniqid();
					$TmpFile = fopen(TMP_PREFIX.$Unique, 'w+');
					fwrite($TmpFile, $Image);
					
					$Image=''; // Free some memory
					
					// Fetch the properties of the image
					$Verify = new ImageVerification(TMP_PREFIX.$Unique);
					if(!$Verify->verify()) continue;
					$Data = $Verify->EphemeralData;
					$DB->query("SELECT Code, Extension FROM uploads WHERE NewHash='".db_string($Data['md5'])."'");
					
					if($DB->record_count()>0) {
						unlink(TMP_PREFIX.$Unique);
						list($Code, $Extension) = $DB->next_record();
						$Results[]=array("status"=>13, "code"=>$Code, "ext"=>$Extension);
						continue;
					}
					
					$Code='';
					while($Code=randFN()) {
						if(!file_exists(IMG_DIR.'/'.$Code)) break;
					}
					rename(TMP_PREFIX.$Unique, IMG_DIR.'/'.$Code);
					
					switch($Data['type']) {
						case 1:
						case 2:
						case 3:
							$DB->query("INSERT INTO uploads
										(NewHash, Extension, Code, Resolution, Size, Type)
										VALUES(
										'".db_string($Data['md5'])."',
										'".db_string($Data['ext'])."',
										'".db_string($Code)."',
										'".db_string($Data['res'])."',
										'".db_string($Data['size'])."',
										'".db_string($Data['type'])."')");
							if($DB->affected_rows()>0) {
								$Results[]=array("status"=>1, "code"=>$Code, "ext"=>$Data['ext']);
							}
						break;
					}
				}

			break;
		}
		$this->Results=&$Results;

		if(count($this->Results)>0)	return true;
		else return false;
	}
}

class Image {
	public $Hash='';
	public $Size=0;
	public $Type=0;
	public $Code='';
	public $Contents='';

	function Image($C) { // Code supplied
//TODO- verify
		$this->NewImage=false;
		$this->Code=&$C;
	}
	function destroy() {
		settype($this, 'null');
	}
	private function getMetaInfo() {
		global $DB, $Cache;
		
		$Size=-1;
		$Type=-1;
		$NewHash=-1;
		if(!($ImgData=$Cache->get_value('v2_imgdata_'.$this->Code)) || !false) {
			$DB->query("SELECT Size, Type, NewHash FROM uploads WHERE Code='".db_string($this->Code)."'");
			if($DB->record_count()>0) {
				list($Size, $Type, $NewHash)=$DB->next_record();
				$Cache->cache_value('v2_imgdata_'.$this->Code, array('size'=>$Size, 'type'=>$Type, 'hash'=>$NewHash), 0);
			} else {
				$Cache->cache_value('v2_imgdata_'.$this->Code, array('size'=>-1, 'type'=>-1, 'hash'=>-1), 120);
			}
		} else {
			$Size=$ImgData['size'];
			$Type=$ImgData['type'];
			$NewHash=$ImgData['hash'];
			if($Size<0 || $Type<0) {
				return false;
			}
		}
		$this->Size=$Size;
		$this->Type=$Type;
		$this->Hash=$NewHash;
		unset($Size, $Type, $NewHash, $ImgData);
		return true;
	}
	// Populate image contents. For new images, we want to use save() instead.
	private function populate() {
		global $DB;
		
		
		$this->Contents=file_get_contents(IMG_DIR."/".$this->Code);
		if($this->Contents=='')
			return false;
		return true;
	}
	// Log an access, handle return of contents
	function access() {
		global $_SERVER, $DB, $MimeType;
		if(!$this->getMetaInfo())
			throw_error(404);
			
		if(empty($this->Contents)) {
			if(!$this->populate())
				throw_error(404);
		}
		//$DB->query("INSERT INTO access(Code,Browser,Referer,IP) VALUES('%s', '%s', '%s', %d)", $code, $_SERVER['HTTP_USER_AGENT'], $_SERVER['HTTP_REFERER'], ip2long($_SERVER['REMOTE_ADDR']));
		
		// Headers
		if($this->Type)
			header("Content-type: ".$MimeType[$this->Type]);
		else
			header("Content-type: ".$MimeType[0]);
		
		if($this->Hash)
			header("Hash: ".$this->Hash);
		
        header("Cache-Control: private, max-age=".CACHE_TIME);
        header("Pragma: private");
        header("Expires: " . date(DATE_RFC822,strtotime(CACHE_EXPIRES)));

        if(isset($_SERVER['HTTP_IF_MODIFIED_SINCE'])){
          // if the browser has a cached version of this image, send 304
          header('Last-Modified: '.$_SERVER['HTTP_IF_MODIFIED_SINCE'],true,304);
          exit;
        }

		echo $this->Contents;
		exit;
	}
}
?>